# Writing Migration and Post Deployment Scripts
In Drift, Migration and Post Deployment scripts are special Javascript files that export an `exec` function. These scripts are used to perform more complex actions on the database. These scripts are run against all providers unlike the object related SQL scripts that are only run against a specific provider.

## Table of Contents

- [What are Migrations?](#what-are-migrations)
- [What are Post Deployment Scripts](#what-are-post-deployment-scripts)
- [Creating Scripts](#creating-scripts)
- [Writing Scripts](#writing-scripts)
  - [Exec Function Arguments](#exec-function-arguments)
  - [DbContext Overview](#dbcontext-overview)
- [Tips](#tips)

## What are Migrations?
Migration scripts are run at the very beginning of the publish process and are only apply to a databaes one time. Once a migration has been successfully applied to a database, it will not be run again. Migrations are best used for:

- Creating schemas, tables or indexes
- Changing existing tables, columns or indexes
- Renaming tables or columns
- Dropping schemas, tables, columns or indexes

## What are Post Deployment Scripts?
Post Deployment scripts are run at the very end of the publish process. Unlike Migrations, Post Deployment scripts are run on every publish. Post Deployment scripts are best used for:

- Seeding data
- Ensuring database roles and permissions are defined

## Creating Scripts
Migration and Post Deployment scripts are created using the `create migration` and `create postDeploy` commands respectively. These commands will generate a Javascript file with a template for the script.

```bash
# Creates a migration script
$ drift create migration my-first-migration
Created file: E:/repos/drift-test/.drift/migrations/1554380701490-my-first-migration.js

# Create a post deployment script
$ drift create postDeploy my-first-post-deploy
Created file: E:/repos/drift-test/.drift/postDeploy/1554380701500-my-first-post-deploy.js
```

## Writing Scripts
These scripts will export an `exec` function that will be used to apply the script. The following is an example of templated file generated by running one of the create commands.

```javascript
/******************************************************************************
 * {scriptType}: {timestamp}-{scriptName}
 *****************************************************************************/
async function exec(context, Sequelize, provider, replacements) {

}

exports.exec = exec
```

### Exec Function Arguments
Drift will provide the `exec` function with the following arguments.

- **context** - [DbContext](#dbcontext-overview) object with methods for manipulating the data structure
- **Sequelize** - Reference to the static instance of Sequelize. Primarily for getting access to defining data types
- **provider** - String indicating database provider the publish is being run against. For example: 'mssql' or 'postgres'
- **replacements** - Map object of standard and custom replacement values available for the publish
  - Standard Replacements
    - *DatabaseName* = Name of the database that is being published
    - *Provider* = String indicating the database provider being published
    - *PublisherUsername* = Name of the user that is publishing the database

### DbContext Overview
The *DbContext* object provided by the `context` provides a wrapper around the Sequelize Query Interface and ensures that the publish transaction is applied to each command that is executed. These are the helper methods provided to you by the *DbContext*:

- **addColumn** - Adds a column to an existing table
  - `(tableName: string | { tableName?: string; schema?: string }, key: string, attribute: ModelAttributeColumnOptions | DataType): Promise<void>`
- **addIndex** - Adds an index to an existing table
  - `(tableName: string, attributes: string[], rawTablename?: string): Promise<void>`
- **changeColumn** - Alter the definition of an exsting column
  - `(tableName: string | { schema?: string; tableName?: string }, attributeName: string, dataTypeOrOptions?: DataType | ModelAttributeColumnOptions): Promise<void>`
- **createSchema** - Creates a new schema
  - `(schema?: string): Promise<void>`
- **createTable** - Creates a new table
  - `(tableName: string | { schema?: string; tableName?: string }, attributes: ModelAttributes): Promise<void>`
- **dropSchema** - Drops an existing schema
  - `(schema?: string): Promise<void>`
- **dropTable** - Drops an existing table
  - `(tableName: string): Promise<void>`
- **removeColumn** - Drops an existing column from a table
  - `(tableName: string | { tableName?: string; schema?: string }, attribute: string): Promise<void>`
- **removeIndex** - Drops an existing index from a table
  - `(tableName: string, indexName: string): Promise<void>`
- **renameColumn** - Renames an exsting column on a table
  - `(tableName: string | { schema?: string; tableName?: string }, attrNameBefore: string, attrNameAfter: string): Promise<void>`
- **renameTable** - Renames an existing table
  - `(before: string, after: string): Promise<void>`
- **runRawQuery** - Executes the provided query text against the database.
  - `(queryText: string): Promise<any>`

## Tips
- Only use the `context` to interact with the database
- Make sure to await promises and not resolve the exec function before it has completed
- Be careful using `context.runRawQuery` the provided text is directly executed against the database
- Generally, Post Deployment scripts will only use `context.runRawQuery`
